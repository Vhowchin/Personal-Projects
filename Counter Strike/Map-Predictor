#Used to be able to predict maps to be played for two teams beforehand. Thus making me able to exploit wrongfully priced odds

map_names = ["Dust2", "Mirage", "Inferno", "Nuke", "Train", "Ancient", "Anubis"]

def get_pick_ban_data(team_a: str, team_b: str):
    print("Pick percentages first for each map:")
    picks_a = {}
    picks_b = {}
    for map_name in map_names:
        picks_a[map_name] = int(input(f"{team_a} {map_name} pick %: ").replace('%', '').strip())
        picks_b[map_name] = int(input(f"{team_b} {map_name} pick %: ").replace('%', '').strip())

    print("Ban percentages for each map:")
    bans_a = {}
    bans_b = {}
    for map_name in map_names:
        bans_a[map_name] = int(input(f"{team_a} {map_name} ban %: ").replace('%', '').strip())
        bans_b[map_name] = int(input(f"{team_b} {map_name} ban %: ").replace('%', '').strip())

    return picks_a, bans_a, picks_b, bans_b

def simulate_bo1_manual(team_a: str, team_b: str, pa, ba, pb, bb):
    all_maps = set(map_names)
    log = []

    def ban_top(team_name, priority_dict):
        sorted_maps = sorted([(m, pct) for m, pct in priority_dict.items() if m in all_maps and pct > 0], key=lambda x: -x[1])
        for map_, _ in sorted_maps:
            log.append(f"{len(log)+1}. {team_name} removed {map_}")
            all_maps.remove(map_)
            return map_
        return None

    def ban_combined(team_name, pick_dict, ban_dict):
        combined = {m: pick_dict[m] + ban_dict[m] for m in all_maps}
        sorted_comb = sorted(combined.items(), key=lambda x: -x[1])
        for map_, _ in sorted_comb:
            log.append(f"{len(log)+1}. {team_name} removed {map_} (combined pick+ban%)")
            all_maps.remove(map_)
            return map_

    ban_top(team_a, ba)

    ban_top(team_a, pb)

    ban_top(team_b, bb)

    ban_top(team_b, pa)

    ban_combined(team_b, pa, bb)

    ban_combined(team_a, pb, ba)

    remaining = list(all_maps)
    remaining.sort(key=lambda x: -pa[x])
    final_map = remaining[0] if remaining else "Unknown"
    log.append(f"{len(log)+1}. {final_map} was left over")

    return log

def main():
    print("Bo1 Map Veto Simulation")

    team_a = input("Enter name of Team A: ").strip()
    team_b = input("Enter name of Team B: ").strip()

    picks_a, bans_a, picks_b, bans_b = get_pick_ban_data(team_a, team_b)
    result = simulate_bo1_manual(team_a, team_b, picks_a, bans_a, picks_b, bans_b)

    print("Veto Order:")
    for line in result:
        print(line)

if __name__ == "__main__":
    main()
